var documenterSearchIndex = {"docs":
[{"location":"APIs/#APIs","page":"APIs","title":"APIs","text":"There are 6 functions that are exported, namely\n\nTeukolsky_radial\nGSN_radial\nTeukolsky_pointparticle_mode\nGSN_pointparticle_mode\nrstar_from_r\nr_from_rstar\n\nand there are 7 custom types that are exported, i.e.\n\nBoundaryCondition\nNormalizationConvention\nMode\nGSNRadialFunction\nTeukolskyRadialFunction\nGSNPointParticleMode\nTeukolskyPointParticleMode\n\nCurrently, only the exported functions and types are documented below. Documentations for private (i.e. unexported) functions will be added at a later stage.","category":"section"},{"location":"APIs/#Functions","page":"APIs","title":"Functions","text":"","category":"section"},{"location":"APIs/#Types","page":"APIs","title":"Types","text":"","category":"section"},{"location":"APIs/#BoundaryCondition","page":"APIs","title":"BoundaryCondition","text":"This is an enum type that can take either one of the four values\n\nvalue \nIN purely ingoing at the horizon\nUP purely outgoing at infinity\nOUT purely outgoing at the horizon\nDOWN purely ingoing at infinity","category":"section"},{"location":"APIs/#NormalizationConvention","page":"APIs","title":"NormalizationConvention","text":"This is an enum type that can take either one of the two values\n\nvalue \nUNIT_GSN_TRANS normalized to have a unit transmission amplitude for the GSN function\nUNIT_TEUKOLSKY_TRANS normalized to have a unit transmission amplitude for the Teukolsky function","category":"section"},{"location":"APIs/#Mode","page":"APIs","title":"Mode","text":"This is a composite struct type that stores information about a mode\n\nfield \ns spin weight s\nl harmonic index ell\nm azimuthal index m\na Kerr spin parameter aM\nomega frequency Momega\nlambda spin-weighted spheroidal eigenvalue lambda","category":"section"},{"location":"APIs/#GSNRadialFunction","page":"APIs","title":"GSNRadialFunction","text":"This is a composite struct type that stores the output from GSN_radial\n\ntip: Tip\nGSNRadialFunction(rstar) is equivalent to GSNRadialFunction.GSN_solution(rstar)[1],  returning only the value of the GSN function evaluated at the tortoise coordinate rstar\n\nfield \nmode a Mode object storing information about the mode\nboundary_condition a BoundaryCondition object storing which boundary condition this function satisfies\nrsin numerical inner boundary r_*^mathrminM where the GSN equation is numerically evolved (r_* is a tortoise coordinate)\nrsout numerical outer boundary r_*^mathrmoutM where the GSN equation is numerically evolved (r_* is a tortoise coordinate)\nrsmp The matching point in tortoise coordinate r_*^mathrmmp if used\nhorizon_expansion_order order of the asymptotic expansion at the horizon\ninfinity_expansion_order order of the asymptotic expansion at infinity\ntransmission_amplitude transmission amplitude in the GSN formalism of this function\nincidence_amplitude incidence amplitude in the GSN formalism of this function\nreflection_amplitude reflection amplitude in the GSN formalism of this function\nnumerical_GSN_solution numerical solution (ODESolution object from DifferentialEquations.jl) to the GSN equation in [rsin, rsout] if applicable; output is a vector  hatX(r_*) dhatX(r_*)dr_* \nnumerical_Riccati_solution numerical solution (ODESolution object from DifferentialEquations.jl) to the GSN equation in the Riccati form if applicable; output is a vector  hatPhi(r_*) dhatPhi(r_*)dr_* \nGSN_solution full GSN solution where asymptotic solutions are smoothly attached; output is a vector  hatX(r_*) dhatX(r_*)dr_* \nnormalization_convention a NormalizationConvention object storing which normalization convention this function adheres to","category":"section"},{"location":"APIs/#TeukolskyRadialFunction","page":"APIs","title":"TeukolskyRadialFunction","text":"This is a composite struct type that stores the output from Teukolsky_radial\n\ntip: Tip\nTeukolskyRadialFunction(r) is equivalent to TeukolskyRadialFunction.Teukolsky_solution(r)[1],  returning only the value of the Teukolsky function evaluated at the Boyer-Lindquist coordinate r\n\nfield \nmode a Mode object storing information about the mode\nboundary_condition a BoundaryCondition object storing which boundary condition this function satisfies\ntransmission_amplitude transmission amplitude in the Teukolsky formalism of this function\nincidence_amplitude incidence amplitude in the Teukolsky formalism of this function\nreflection_amplitude reflection amplitude in the Teukolsky formalism of this function\nGSN_solution a GSNRadialFunction object storing the corresponding GSN function\nTeukolsky_solution Teukolsky solution where asymptotic solutions are smoothly attached; output is a vector  hatR(r) dhatR(r)dr \nnormalization_convention a NormalizationConvention object storing which normalization convention this function adheres to","category":"section"},{"location":"APIs/#GSNPointParticleMode","page":"APIs","title":"GSNPointParticleMode","text":"This is a composite struct type that stores the output from GSN_pointparticle_mode\n\nfield \nmode a Mode object storing information about the mode (including the frequency)\namplitude the amplitude of the inhomogeneous GSN solution at infinity or at the horizon such that X^infty_ell m omega =  amplitude e^i omega r_* or X^mathrmH_ell m omega = amplitude e^- i left omega - ma(2r_+) right r_*\nenergy_flux the energy flux emitted towards infinity or towards the horizon\nangular_momentum_flux the angular momentum flux towards infinity or towards the horizon\nCarter_const_flux the Carter constant flux towards infinity or towards the horizon\ntrajectory the trajectory/geodesic that the particle follows\nY_solution the auxiliary function Y used in the calculation\nSWSH the spin-weighted spheroidal harmonic used in the calculation\nmethod a named tuple storing the method and grid size used in computing the convolution integral","category":"section"},{"location":"APIs/#TeukolskyPointParticleMode","page":"APIs","title":"TeukolskyPointParticleMode","text":"This is a composite struct type that stores the output from Teukolsky_pointparticle_mode\n\nfield \nmode a Mode object storing information about the mode (including the frequency)\namplitude the amplitude of the inhomogeneous Teukolsky solution at infinity or at the horizon such that R^infty_ell m omega = amplitude r^-(2s+1) e^i omega r_* or R^mathrmH_ell m omega = amplitude Delta^-s e^- i left omega - ma(2r_+) right r_*\nenergy_flux the energy flux emitted towards infinity or towards the horizon\nangular_momentum_flux the angular momentum flux towards infinity or towards the horizon\nCarter_const_flux the Carter constant flux towards infinity or towards the horizon\ntrajectory the trajectory/geodesic that the particle follows\nY_solution the auxiliary function Y used in the calculation\nSWSH the spin-weighted spheroidal harmonic used in the calculation\nmethod a named tuple storing the method and grid size used in computing the convolution integral","category":"section"},{"location":"APIs/#GeneralizedSasakiNakamura.Teukolsky_radial","page":"APIs","title":"GeneralizedSasakiNakamura.Teukolsky_radial","text":"Teukolsky_radial(s::Int, l::Int, m::Int, a, omega, boundary_condition, rsin, rsout; horizon_expansion_order::Int=_DEFAULT_horizon_expansion_order, infinity_expansion_order::Int=_DEFAULT_infinity_expansion_order, method=\"auto\", data_type=Solutions._DEFAULTDATATYPE,  ODE_algorithm=Solutions._DEFAULTSOLVER, tolerance=Solutions._DEFAULTTOLERANCE, rsmp=nothing)\n\nCompute the Teukolsky function for a given mode (specified by s the spin weight, l the harmonic index, m the azimuthal index, a the Kerr spin parameter, and omega the frequency [which can be complex])  and boundary condition specified by boundary_condition, which can be either\n\n- `IN` for purely-ingoing at the horizon,\n- `UP` for purely-outgoing at infinity,\n- `OUT` for purely-outgoing at the horizon,\n- `DOWN` for purely-ingoing at infinity.\n\nNote that the OUT and DOWN solutions are constructed by linearly combining the IN and UP solutions, respectively.\n\nThe full GSN solution is converted to the corresponding Teukolsky solution (R(r) dRdr) and  the incidence, reflection and transmission amplitude are converted from the GSN formalism to the Teukolsky formalism  with the normalization convention that the transmission amplitude is normalized to 1 (i.e. normalization_convention=UNIT_TEUKOLSKY_TRANS).\n\nNote, however, when omega = 0, the exact Teukolsky function expressed using Gauss hypergeometric functions will be returned (i.e., instead of using the GSN formalism).  In this case, only s, l, m, a, omega, boundary_condition will be parsed.\n\nWith complex values of omega, the Teukolsky function is evaluated as a function of r, where the value at the corresponding location rho = r_*(r) in mathbbR along the rotated integration path on the complex plane is returned.\n\n\n\n\n\nTeukolsky_radial(s::Int, l::Int, m::Int, a, omega; data_type=Solutions._DEFAULTDATATYPE, ODE_algorithm=Solutions._DEFAULTSOLVER, tolerance=Solutions._DEFAULTTOLERANCE, method=\"auto\")\n\nCompute the Teukolsky function for a given mode (specified by s the spin weight, l the harmonic index, m the azimuthal index, a the Kerr spin parameter, and omega the frequency) with the purely-ingoing boundary condition at the horizon (IN) and the purely-outgoing boundary condition at infinity (UP).\n\nNote that for real frequencies, the numerical inner boundary (rsin) and outer boundary (rsout) are set to the default values _DEFAULT_rsin and _DEFAULT_rsout, respectively, while the order of the asymptotic expansion at the horizon and infinity are determined automatically. As for complex frequencies, the numerical inner and the outer boundaries are determined automatically, while the order of the asymptotic expansion at the horizon and infinity are set to _DEFAULT_horizon_expansion_order_for_cplx_freq and _DEFAULT_infinity_expansion_order_for_cplx_freq, respectively.\n\n\n\n\n\n","category":"function"},{"location":"APIs/#GeneralizedSasakiNakamura.GSN_radial","page":"APIs","title":"GeneralizedSasakiNakamura.GSN_radial","text":"GSN_radial(s::Int, l::Int, m::Int, a, omega, boundary_condition, rsin, rsout; horizon_expansion_order::Int=_DEFAULT_horizon_expansion_order, infinity_expansion_order::Int=_DEFAULT_infinity_expansion_order, method=\"auto\", data_type=Solutions._DEFAULTDATATYPE,  ODE_algorithm=Solutions._DEFAULTSOLVER, tolerance=Solutions._DEFAULTTOLERANCE, rsmp=nothing)\n\nCompute the GSN function for a given mode (specified by s the spin weight, l the harmonic index, m the azimuthal index, a the Kerr spin parameter, and omega the frequency [which can be complex])  and boundary condition specified by boundary_condition, which can be either\n\n- `IN` for purely-ingoing at the horizon,\n- `UP` for purely-outgoing at infinity,\n- `OUT` for purely-outgoing at the horizon,\n- `DOWN` for purely-ingoing at infinity.\n\nNote that the OUT and DOWN solutions are constructed by linearly combining the IN and UP solutions, respectively.\n\nThe GSN function is numerically solved, for real values of omega, in the interval of tortoise coordinates r_* in [rsin, rsout] using the ODE solver (from DifferentialEquations.jl) specified by ODE_algorithm (default: Vern9())  with tolerance specified by tolerance (default: 1e-12). The ODE to be solved is determined by the keyword method (default: auto), which can be either linear (solving the GSN equation in a linear form) or Riccati (solving the GSN equation in a nonlinear form). By default the data type used is ComplexF64 (i.e. double-precision floating-point number) but it can be changed by specifying data_type (e.g. Complex{BigFloat} for complex arbitrary precision number).\n\nWith complex values of omega, the GSN function is solved along a rotated path on the complex plane of r_*,  where the path consists of two broken line segments parametrized by a real variable/a new coordinate rho. The angle with which the path is rotated is determined by the frequency omega, the Kerr spin parameter a and the azimuthal index m,  such that the GSN function still behaves like a plane wave near the horizon and spatial infinity.  At rho = 0, the path intersects with the real axis at r_* = r_*^rmmp (rsmp, default to be nothing, which means it will be determined automatically). Both the numerical and semi-analytical GSN solutions are evaluated as functions of rho instead of the now-complex r_*.\n\nWhile the numerical GSN solution is only accurate in the range [rsin, rsout],  the full GSN solution is constructed by smoothly attaching the asymptotic solutions near horizon (up to horizon_expansion_order-th order)  and infinity (up to infinity_expansion_order-th order). Therefore, the now-semi-analytical GSN solution is accurate everywhere.\n\nNote, however, when omega = 0, the exact GSN function expressed using Gauss hypergeometric functions will be returned (i.e., instead of being solved numerically).  In this case, only s, l, m, a, omega, boundary_condition will be parsed.\n\nReturn a GSNRadialFunction object which contains all the information about the GSN solution.\n\n\n\n\n\nGSN_radial(s::Int, l::Int, m::Int, a, omega; data_type=Solutions._DEFAULTDATATYPE, ODE_algorithm=Solutions._DEFAULTSOLVER, tolerance=Solutions._DEFAULTTOLERANCE, method=\"auto\")\n\nCompute the GSN function for a given mode (specified by s the spin weight, l the harmonic index, m the azimuthal index, a the Kerr spin parameter, and omega the frequency) with the purely-ingoing boundary condition at the horizon (IN) and the purely-outgoing boundary condition at infinity (UP).\n\nNote that for real frequencies, the numerical inner boundary (rsin) and outer boundary (rsout) are set to the default values _DEFAULT_rsin and _DEFAULT_rsout, respectively, while the order of the asymptotic expansion at the horizon and infinity are determined automatically. As for complex frequencies, the numerical inner and the outer boundaries are determined automatically, while the order of the asymptotic expansion at the horizon and infinity are set to _DEFAULT_horizon_expansion_order_for_cplx_freq and _DEFAULT_infinity_expansion_order_for_cplx_freq, respectively.\n\n\n\n\n\n","category":"function"},{"location":"APIs/#GeneralizedSasakiNakamura.Coordinates.rstar_from_r","page":"APIs","title":"GeneralizedSasakiNakamura.Coordinates.rstar_from_r","text":"rstar_from_r(a, r)\n\nConvert a Boyer-Lindquist coordinate r to the corresponding tortoise coordinate rstar.\n\n\n\n\n\n","category":"function"},{"location":"APIs/#GeneralizedSasakiNakamura.Coordinates.r_from_rstar","page":"APIs","title":"GeneralizedSasakiNakamura.Coordinates.r_from_rstar","text":"r_from_rstar(a, rstar)\n\nConvert a tortoise coordinate rstar to the corresponding Boyer-Lindquist coordiante r.  It uses a bisection method when rstar <= 0, and Newton method otherwise.\n\nThe function assumes that r geq r_+ where r_+ is the outer event horizon.\n\n\n\n\n\n","category":"function"},{"location":"APIs/#GeneralizedSasakiNakamura.Teukolsky_pointparticle_mode","page":"APIs","title":"GeneralizedSasakiNakamura.Teukolsky_pointparticle_mode","text":"Teukolsky_pointparticle_mode(s::Int, l::Int, m::Int, n::Int, k::Int, a, p, e, x; method=\"auto\", N::Int, K::Int)\n\nCompute the amplitude of the inhomogeneous Teukolsky solution at infinity (for s = - 2) and at horizon (for s = + 2) due to a point particle on a generic timelike bound orbit around a Kerr black hole, with a spin parameter of a, for a given mode (specified by s the spin weight, l the harmonic index, m the azimuthal index, n the radial index and k the polar index). The orbit is specified by p the semi-latus rectum, e the eccentricity and x the inclination parameter (x equiv cos theta_mathrminc).\n\nIn addition, we compute also the energy, angular momentum and Carter constant flux at infinity (for s = - 2) and the horizon (for s = + 2). Note that these values are formalism-independent.\n\nThe numerical method to compute the convolution integral is specified by method (default: auto), which can either be trapezoidal or levin. We sample the trajectory over a grid of size N x K, where N and K are the number of Chebyshev nodes in the radial and the polar direction, respectively. Note that they must be powers of 2.\n\n\n\n\n\n","category":"function"},{"location":"APIs/#GeneralizedSasakiNakamura.GSN_pointparticle_mode","page":"APIs","title":"GeneralizedSasakiNakamura.GSN_pointparticle_mode","text":"GSN_pointparticle_mode(s::Int, l::Int, m::Int, n::Int, k::Int, a, p, e, x; method=\"auto\", N::Int, K::Int)\n\nCompute the amplitude of the inhomogeneous GSN solution at infinity (for s = - 2) and at horizon (for s = + 2) due to a point particle on a generic timelike bound orbit around a Kerr black hole, with a spin parameter of a, for a given mode (specified by s the spin weight, l the harmonic index, m the azimuthal index, n the radial index and k the polar index). The orbit is specified by p the semi-latus rectum, e the eccentricity and x the inclination parameter (x equiv cos theta_mathrminc).\n\nIn addition, we compute also the energy, angular momentum and Carter constant flux at infinity (for s = - 2) and the horizon (for s = + 2). Note that these values are formalism-independent.\n\nThe numerical method to compute the convolution integral is specified by method (default: auto), which can either be trapezoidal or levin. We sample the trajectory over a grid of size N x K, where N and K are the number of Chebyshev nodes in the radial and the polar direction, respectively. Note that they must be powers of 2.\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"Pages = [\"examples.md\"]","category":"section"},{"location":"examples/#Example-1:-Solving-and-visualizing-some-Teukolsky-and-GSN-functions","page":"Examples","title":"Example 1: Solving and visualizing some Teukolsky and GSN functions","text":"In this example, we solve for the Teukolsky and the GSN function with s = -2 ell = 2 m = 2 a = 07 omega = 025 that satisfy the purely outgoing condition at infinity (i.e. UP).\n\nusing GeneralizedSasakiNakamura\nusing Plots, LaTeXStrings\n\n# Specify which mode and what boundary condition\ns=-2; l=2; m=2; a=0.7; omega=0.25; bc=UP; # Change to bc=IN to solve for R^in or X^in instead\n# Specify where to match to ansatzes\nrsin=-20; rsout=250;\n\n# NOTE: julia uses 'just-ahead-of-time' compilation. Calling this the first time in each session will take some time\nR = Teukolsky_radial(s, l, m, a, omega, bc, rsin, rsout);\n\n# Set up a grid of the tortoise coordinate rs\nrsgrid = collect(-30:1:300); # Does not have to be within [rsin, rsout]\n# Set up a grid of the Boyer-Lindquist r coordinate\n# Convert from rsgrid using r_from_rstar(a, rs)\nrgrid = [r_from_rstar(a, rs) for rs in rsgrid];\n\n# Visualize the Teukolsky function\n\n# Use the 'shortcut' interface to access the function\nplot(rgrid, [real(R(r)) for r in rgrid], label=\"real\")\n# Use the full interface to access the function (and its derivative)\nplot!(rgrid, [imag(R.Teukolsky_solution(r)[1]) for r in rgrid], label=\"imag\")\nplot!(\n    legendfontsize=14,\n    xguidefontsize=14,\n    yguidefontsize=14,\n    xtickfontsize=14,\n    ytickfontsize=14,\n    foreground_color_legend=nothing,\n    background_color_legend=nothing,\n    legend=:topleft,\n    xlabel=L\"r/M\",\n    ylabel=L\"R(r)\",\n)\ntitle!(\"$(R.boundary_condition) solution\")\n\n(Image: R.png)\n\n# Visualize the underlying GSN function\n\n# Use the 'shortcut' interface to access the function\nplot(rsgrid, [real(R.GSN_solution(rs)) for rs in rsgrid], label=\"real\")\n# Use the full interface to access the function (and its derivative)\nplot!(rsgrid, [imag(R.GSN_solution.GSN_solution(rs)[1]) for rs in rsgrid], label=\"imag\")\nplot!(\n    legendfontsize=14,\n    xguidefontsize=14,\n    yguidefontsize=14,\n    xtickfontsize=14,\n    ytickfontsize=14,\n    foreground_color_legend=nothing,\n    background_color_legend=nothing,\n    legend=:bottomright,\n    xlabel=L\"r_{*}/M\",\n    ylabel=L\"X(r_{*})\",\n)\ntitle!(\"$(R.boundary_condition) solution\")\n\n(Image: X.png)\n\n# Visualize the underlying complex frequency function\n# NOTE: for this one, rstar has to be within [rsin, rsout]\nplot(collect(rsin:0.1:rsout), [real(R.GSN_solution.numerical_Riccati_solution(rs)[2]) for rs in rsin:0.1:rsout], label=\"real\")\n# Use the full interface to access the function (and its derivative)\nplot!(collect(rsin:0.1:rsout), [imag(R.GSN_solution.numerical_Riccati_solution(rs)[2]) for rs in rsin:0.1:rsout], label=\"imag\")\nplot!(\n    legendfontsize=14,\n    xguidefontsize=14,\n    yguidefontsize=14,\n    xtickfontsize=14,\n    ytickfontsize=14,\n    foreground_color_legend=nothing,\n    background_color_legend=nothing,\n    legend=:bottomright,\n    xlabel=L\"r_{*}/M\",\n    ylabel=L\"d\\Phi(r_{*})/dr_{*}\",\n)\ntitle!(\"$(R.boundary_condition) solution\")\n\n(Image: dPhidrs.png)","category":"section"},{"location":"examples/#Example-2:-Plotting-reflectivity-of-black-holes-(in-GSN-formalism)","page":"Examples","title":"Example 2: Plotting reflectivity of black holes (in GSN formalism)","text":"using GeneralizedSasakiNakamura\nusing Plots, LaTeXStrings\n\nsarr = [-2, -1, 0, 1, 2];\nl=2;m=2;a=0.0;\nreflectivity_from_inf_nonrotating = Dict()\nomegas = collect(0.01:0.01:2.0);\n\nfor s in sarr\n    reflectivity_from_inf_nonrotating[s] = []\n    for omg in omegas\n        Xin = GSN_radial(s, l, m, a, omg, IN, -20, 250)\n        append!(reflectivity_from_inf_nonrotating[s], Xin.reflection_amplitude/Xin.incidence_amplitude)\n    end\nend\n\nplot(omegas, abs.(reflectivity_from_inf_nonrotating[-2]), linewidth=2, color=theme_palette(:auto)[1], label=L\"s = \\pm 2\")\nplot!(omegas, abs.(reflectivity_from_inf_nonrotating[-1]), linewidth=2, color=theme_palette(:auto)[2], label=L\"s = \\pm 1\")\nplot!(omegas, abs.(reflectivity_from_inf_nonrotating[0]), linewidth=2, color=theme_palette(:auto)[3], label=L\"s = 0\")\nplot!(\n    legendfontsize=14,\n    xguidefontsize=14,\n    yguidefontsize=14,\n    xtickfontsize=14,\n    ytickfontsize=14,\n    foreground_color_legend=nothing,\n    background_color_legend=nothing,\n    legend=:bottomright,\n    formatter=:latex,\n    xlabel=L\"M\\omega\",\n    ylabel=L\"| \\hat{B}^{\\mathrm{ref}}_{\\mathrm{SN}}/\\hat{B}^{\\mathrm{inc}}_{\\mathrm{SN}} |\",\n    left_margin = 2Plots.mm,\n    right_margin = 3Plots.mm,\n)\ntitle!(L\"a/M = 0\")\n\n(Image: reflectivity-aOverM_0.png)\n\nsarr = [-2, -1, 0, 1, 2];\nl=2;m=2;a=0.7;\nreflectivity_from_inf_rotating = Dict()\nomegas = collect(0.01:0.01:2.0);\n\nfor s in sarr\n    reflectivity_from_inf_rotating[s] = []\n    for omg in omegas\n        Xin = GSN_radial(s, l, m, a, omg, IN, -20, 250)\n        append!(reflectivity_from_inf_rotating[s], Xin.reflection_amplitude/Xin.incidence_amplitude)\n    end\nend\n\nplot(omegas, abs.(reflectivity_from_inf_rotating[-2]), linewidth=2, color=theme_palette(:auto)[1], label=L\"s = -2\")\nplot!(omegas, abs.(reflectivity_from_inf_rotating[-1]), linewidth=2, color=theme_palette(:auto)[2], label=L\"s = -1\")\nplot!(omegas, abs.(reflectivity_from_inf_rotating[0]), linewidth=2, color=theme_palette(:auto)[3], label=L\"s = 0\")\nplot!(omegas, abs.(reflectivity_from_inf_rotating[1]), linewidth=2, color=theme_palette(:auto)[4], label=L\"s = 1\")\nplot!(omegas, abs.(reflectivity_from_inf_rotating[2]), linewidth=2, color=theme_palette(:auto)[5], label=L\"s = 2\")\nplot!(\n    legendfontsize=14,\n    xguidefontsize=14,\n    yguidefontsize=14,\n    xtickfontsize=14,\n    ytickfontsize=14,\n    foreground_color_legend=nothing,\n    background_color_legend=nothing,\n    legend=:bottomright,\n    formatter=:latex,\n    xlabel=L\"M\\omega\",\n    ylabel=L\"| \\hat{B}^{\\mathrm{ref}}_{\\mathrm{SN}}/\\hat{B}^{\\mathrm{inc}}_{\\mathrm{SN}} |\",\n    left_margin = 2Plots.mm,\n    right_margin = 3Plots.mm,\n)\ntitle!(L\"a/M = 0.7\")\n\n(Image: reflectivity-aOverM_0p7.png)","category":"section"},{"location":"examples/#Example-3:-Calculating-the-gravitational-waveform-induced-by-a-particle-falling-radially-into-a-Kerr-black-hole","page":"Examples","title":"Example 3: Calculating the gravitational waveform induced by a particle falling radially into a Kerr black hole","text":"Here, we show an example of our code implementation in calculating the gravitational waveform induced by a particle falling radially into a Kerr black hole along its spin axis (i.e. theta=0 or z-axis). The particle has zero initial velocity at infinity, which we refer to as rest limit in the paper. It also means the orbital energy per mass is mathcalE=1.\n\nusing GeneralizedSasakiNakamura\nusing SpinWeightedSpheroidalHarmonics\nusing DifferentialEquations\nusing Statistics\nusing CubicSplines\nusing QuadGK\nusing Plots, LaTeXStrings\n\nConstruct the source term \n\nmathcalW_nn=f_0(r)e^ichi(r)+int_r^infty f_1(r_1)e^ichi(r_1)d r_1+int_r^infty dr_1int_r_1^infty f_2(r_2)e^ichi(r_2)dr_2\n\n,\n\nwhere\n\nf_0(r)=fracmathscrAomega^2w_nn^(0)(r)\n\n, \n\nf_1(r)=fracmathscrAomega^2leftw_nn^(0)(r)+ixi(r)w_nn^(0)(r)+w_nn^(1)(r)right\n\n, \n\nf_2(r)=fracmathscrAomega^2leftw_nn^(1)(r)+ixi(r)w_nn^(1)(r)right\n\n,\n\nchi(r)=omega leftt(r)+r_*(r)right\n\n,\n\nwith\n\nw_nn^(0)(r)=frac12r^2rhobarrho^2u^r mathscrL_1^daggerleftrho^-4mathscrL_2^daggerleft(rho^3Sright)right\n\n,\n\nw_nn^(1)(r)=w_nn^(0)(r)left(fracmathcalNu^rright)fracu^rmathcalN+w_nn^(0)(r)+ixi(r)w_nn^(0)(r)\n\n.\n\nIn our case xi(r)equiv 0, mathscrA=-1 and \n\nu^t=fracr^2+a^2Delta^2\n\n,\n\nu^r=-sqrtfrac2rr^2+a^2\n\n,\n\nmathcalN=u^t+fracSigmaDeltau^r=fracr^2+a^2Deltaleft(1-sqrtfrac2rr^2+a^2right)\n\n.\n\nOne can see that mathcalN(rto r_+) is non-vanishing but hard to compute directly because both the denominator and the term in the bracket are zero in the limit. We also need its first- and second-order derivatives with respect to r. So we expand them into series of x=r-r_+ when r_*to-infty, namely\n\nmathcalN(rto r_+)=n^0_0+n^0_1x+n^0_2x^2+dots\n\n,\n\nmathcalN(rto r_+)=n^1_0+n^1_1x+n^1_2x^2+dots\n\n,\n\nmathcalN(rto r_+)=n^2_0+n^2_1x+n^2_2x^2+dots\n\n.\n\nIf x3times10^-3, we can reach the 10^-12 relative tolerance by truncating at n_5^012.\n\nfunction N_expansions(r, a)\n    rp = 1 + sqrt(1 - a^2)\n    x = r - rp\n    # We find it more convenient to work with ν = arcsin(a)\n    ν = asin(a)\n    if x < 3e-3\n        # The expansion coefficients of N\n        n00 = 1 / 2\n        n01 = 1 / (8 + 8 * sec(ν))\n        n02 = (sin(ν)^2 - cos(ν)) / (16 * (1 + cos(ν))^2)\n        n03 = (5 * cos(ν)^3 - 8 * sin(ν)^2) / (128 * (1 + cos(ν))^3)\n        n04 = (-7 * cos(ν) + (19 + 15 * cos(ν)) * sin(ν)^2 - 7 * sin(ν)^4)/(256 * (1 + cos(ν))^4)\n        n05 = (21 * cos(ν) - 4 * (15 + 19 * cos(ν) + 7 * cos(2 * ν)) * sin(ν)^2\n             + 21 * cos(ν) * sin(ν)^4)/(1024 * (1 + cos(ν))^5)\n        N = n00 + n01 * x + n02 * x^2 + n03 * x^3 + n04 * x^4 + n05 * x^5\n\n        # The expansion coefficients of N'\n        n10 = 1/(8 + 8 * sec(ν))\n        n11 = -(1/64) * (-1 + 2 * cos(ν) + cos(2 * ν)) * sec(ν/2)^4\n        n12 = (3 * (-16 + 15 * cos(ν) + 16 * cos(2 * ν) + 5 * cos(3 * ν)) * sec(ν/2)^6)/4096\n        n13 = -(((-55 + 26 * cos(ν) + 48 * cos(2 * ν) + 30 * cos(3 * ν) \n            + 7 * cos(4 * ν)) * sec(ν/2)^8)/8192)\n        n14 = (5 * (-368 + 74 * cos(ν) + 256 * cos(2 * ν) + 241 * cos(3 * ν) \n            + 112 * cos(4 * ν) + 21 * cos(5 * ν)) * sec(ν/2)^10)/524288\n        n15 = -((3 * (-1234 + 36 * cos(ν) + 639 * cos(2 * ν) + 810 * cos(3 * ν) \n            + 562 * cos(4 * ν) + 210 * cos(5 * ν) + 33 * cos(6 * ν)) * sec(ν/2)^12)/2097152)\n        Np = n10 + n11 * x + n12 * x^2 + n13 * x^3 + n14 * x^4 + n15 * x^5\n\n        # The expansion coefficients of N''\n        n20 = -(1/64) * (-1 + 2 * cos(ν) + cos(2 * ν)) * sec(ν/2)^4\n        n21 = (3 * (-16 + 15 * cos(ν) + 16 * cos(2 * ν) + 5 * cos(3 * ν)) * sec(ν/2)^6)/2048\n        n22 = -((3 * (-55 + 26 * cos(ν) + 48 * cos(2 * ν) + 30 * cos(3 * ν) \n            + 7 * cos(4 * ν)) * sec(ν/2)^8)/8192)\n        n23 = (5 * (-368 + 74 * cos(ν) + 256 * cos(2 * ν) + 241 * cos(3 * ν) + 112 * cos(4 * ν) \n            + 21 * cos(5 * ν)) * sec(ν/2)^10)/131072\n        n24 = -((15 * (-1234 + 36 * cos(ν) + 639 * cos(2 * ν) + 810 * cos(3 * ν) + 562 * cos(4 * ν) \n            + 210 * cos(5 * ν) + 33 * cos(6 * ν)) * sec(ν/2)^12)/2097152)\n        n25 = (1/134217728) * 21 * (-33472 - 2777 * cos(ν) + 12192 * cos(2 * ν) + 19697 * cos(3 * ν) \n            + 18112 * cos(4 * ν) + 10107 * cos(5 * ν) + 3168 * cos(6 * ν) + 429 * cos(7 * ν)) * sec(ν/2)^14\n        Npp = n20 + n21 * x + n22 * x^2 + n23 * x^3 + n24 * x^4 + n25 * x^5\n    else\n        N = 1/(1 + (sqrt(2) * r)/sqrt(r * (a^2 + r^2)))\n        Np = (-a^2 * r + r^3)/(sqrt(2) * sqrt(r * (a^2 + r^2)) * (sqrt(2) * r + sqrt(r * (a^2 + r^2)))^2)\n        Npp = (r * (a^4 * (6 * r + sqrt(2) * sqrt(r * (a^2 + r^2))) - r^4 * (2 * r \n            + 3 * sqrt(2) * sqrt(r * (a^2 + r^2))) + 2 * a^2 * r^2 * (6 * r + 5 * sqrt(2) \n            * sqrt(r * (a^2 + r^2))))) / (4 * (r * (a^2 + r^2))^(3/2) * (sqrt(2) * r + sqrt(r * (a^2 + r^2)))^3)\n    end\n    return N, Np, Npp\nend\n\nWe define \n\nP = frac12r^2rhobarrho^2=-fracr^22(r-ia)(r+ia)^2\n\n,\n\nQ = mathscrL_1^daggerleftrho^-4mathscrL_2^daggerleft(rho^3Sright)right = 4(ia-r)leftfracpartial^2_-2S_ell 0^aomega(theta)partialtheta^2right_theta=0\n\n,\n\nU = u^r\n\n.\n\nThe components in f_012 will be\n\nw_nn^(0) = PUQ\n\n,\n\nw_nn^(0) = PUQ+PUQ+PUQ\n\n,\n\nw_nn^(0)=PUQ+PUQ+PUQ+2PUQ+2PUQ+2PUQ\n\n,\n\nw_nn^(1) = w_nn^(0)left(fracmathcalNmathcalN-fracUUright)+w_nn^(0)\n\n,\n\nw_nn^(1) = w_nn^(0)(fracmathcalNmathcalN-fracUU)+w_nn^(0)leftfracmathcalNmathcalN-left(fracmathcalNmathcalNright)^2-fracUU+left(fracUUright)^2right+w_nn^(0)\n\n.\n\nNumerically, we give f_012 as functions of r\n\nfunction f_terms(a, ω, S2)\n    function f_r(r)\n        N, Np, Npp = N_expansions(r, a)\n\n        P = - r^2 / (2 * (-im*a + r) * (im*a + r)^2)\n        Pp = (r * (-2*a^2 - im*a*r + r^2))/(2 * (-im*a + r)^2 * (im*a + r)^3)\n        Ppp = (im * (a^4 + 2*im*a^3*r - 6*a^2*r^2 - 2*im*a*r^3 + r^4))/((a - im*r)^4 * (a + im*r)^3)\n\n        Q = 4 * (im * a - r) * S2\n        Qp =  - 4 * S2\n        Qpp = 0\n\n        U = -((sqrt(2) * r)/sqrt(r * (a^2 + r^2)))\n        Up = (r * (-a^2 + r^2))/(sqrt(2) * (r * (a^2 + r^2))^(3/2))\n        Upp = (r * (a^4 + 10 * a^2 * r^2 - 3 * r^4))/(2 * sqrt(2) * (r * (a^2 + r^2))^(5/2))\n\n        wnn0 = P*U*Q\n        dwnn0 = Pp*U*Q + P*Up*Q + P*U*Qp\n        ddwnn0 = Ppp*U*Q + P*Upp*Q + P*U*Qpp + 2*Pp*Up*Q + 2*Pp*U*Qp + 2*P*Up*Qp\n        wnn1 = wnn0 * (Np/N - Up/U) + dwnn0\n        dwnn1 = dwnn0 * (Np/N - Up/U) + wnn0 * (Npp/N - (Np/N)^2 - Upp/U + (Up/U)^2) + ddwnn0\n\n        f0 = - wnn0 / ω^2\n        f1 = - (wnn1 + dwnn0) / ω^2\n        f2 = - dwnn1 / ω^2\n\n        return f0, f1, f2\n    end\n    return f_r\nend\n\nOne can reproduce Figure 4(a) of our paper by\n\nrs_values = range(-100, 1000, 1000)\na = 0.9\nω = 0.5\nS2 = 1\nf_r = f_terms(a, ω, S2)\nr_values = [r_from_rstar(a, r) for r in rs_values]\nf0_values = [abs(f_r(r)[1]) for r in r_values]\nf1_values = [abs(f_r(r)[2]) for r in r_values]\nf2_values = [abs(f_r(r)[3]) for r in r_values]\nr_benchmark = 10 .^range(2, 3, 20)\nr_to_minus_half = [5*r^(-0.5) for r in r_benchmark]\nr_to_minus_onehalf = [2*r^(-1.5) for r in r_benchmark]\nr_to_minus_three = [5*r^(-3.0) for r in r_benchmark]\n\nf_terms_rest = plot(r_values,\n    f0_values,\n    xlabel = L\"r/M\",\n    label = L\"f_0\",\n    legendfont = font(12,\"Computer Modern\"),\n    legendfontsize=14,\n    xguidefontsize=14,\n    yguidefontsize=14,\n    xtickfontsize=14,\n    ytickfontsize=14,\n    foreground_color_legend=nothing,\n    background_color_legend=nothing,\n    legend=:topright,\n    formatter=:latex,\n    yscale =:log10,\n    xscale =:log10,\n    linewidth=2.0,\n    left_margin = 2Plots.mm,\n    right_margin = 3Plots.mm)\nplot!(r_values,\n    f1_values,\n    xlabel = L\"r/M\",\n    label = L\"f_1\",\n    legendfont = font(12,\"Computer Modern\"),\n    legendfontsize=14,\n    xguidefontsize=14,\n    yguidefontsize=14,\n    xtickfontsize=14,\n    ytickfontsize=14,\n    foreground_color_legend=nothing,\n    background_color_legend=nothing,\n    legend=:topright,\n    formatter=:latex,\n    yscale =:log10,\n    xscale =:log10,\n    linewidth=2.0,\n    left_margin = 2Plots.mm,\n    right_margin = 3Plots.mm)\nplot!(r_values,\n    f2_values,\n    xlabel = L\"r/M\",\n    label = L\"f_2\",\n    legendfont = font(12,\"Computer Modern\"),\n    legendfontsize=14,\n    xguidefontsize=14,\n    yguidefontsize=14,\n    xtickfontsize=14,\n    ytickfontsize=14,\n    foreground_color_legend=nothing,\n    background_color_legend=nothing,\n    legend=:topright,\n    formatter=:latex,\n    yscale =:log10,\n    xscale =:log10,\n    linewidth=2.0,\n    left_margin = 2Plots.mm,\n    right_margin = 3Plots.mm)\nplot!(r_benchmark,\n    r_to_minus_half,\n    xlabel = L\"r/M\",\n    label = L\"1/r^{1/2}\",\n    legendfont = font(12,\"Computer Modern\"),\n    legendfontsize=14,\n    xguidefontsize=14,\n    yguidefontsize=14,\n    xtickfontsize=14,\n    ytickfontsize=14,\n    foreground_color_legend=nothing,\n    background_color_legend=nothing,\n    legend=:topright,\n    formatter=:latex,\n    yscale =:log10,\n    xscale =:log10,\n    linewidth=1.0,\n    left_margin = 2Plots.mm,\n    right_margin = 3Plots.mm,\n    color =:black,\n    linestyle =:dashdot)\nplot!(r_benchmark,\n    r_to_minus_onehalf,\n    xlabel = L\"r/M\",\n    label = L\"1/r^{3/2}\",\n    legendfont = font(12,\"Computer Modern\"),\n    legendfontsize=14,\n    xguidefontsize=14,\n    yguidefontsize=14,\n    xtickfontsize=14,\n    ytickfontsize=14,\n    foreground_color_legend=nothing,\n    background_color_legend=nothing,\n    legend=:topright,\n    formatter=:latex,\n    yscale =:log10,\n    xscale =:log10,\n    linewidth=1.0,\n    left_margin = 2Plots.mm,\n    right_margin = 3Plots.mm,\n    color =:black,\n    linestyle =:dash)\nplot!(r_benchmark,\n    r_to_minus_three,\n    xlabel = L\"r/M\",\n    label = L\"1/r^3\",\n    title = L\"\\mathcal{E}=1\",\n    legendfont = font(12,\"Computer Modern\"),\n    legendfontsize=12,\n    xguidefontsize=14,\n    yguidefontsize=14,\n    xtickfontsize=14,\n    ytickfontsize=14,\n    foreground_color_legend=nothing,\n    background_color_legend=nothing,\n    legend=:bottomleft,\n    formatter=:latex,\n    yscale =:log10,\n    xscale =:log10,\n    linewidth=1.0,\n    color =:black,\n    left_margin = 2Plots.mm,\n    right_margin = 3Plots.mm,\n    linestyle =:dot,\n    ylim = (4e-9, 50))\n\n(Image: f_terms_scaling.png)\n\nThe phase term \n\nt(r_*)=int_r_*^rm in^r_*fracd td r fracd rd tilder_* d tilder_*=int_r_*^rm in^r_*fracu^tu^r fracDeltar^2+a^2 d tilder_* = int_r_*^rm in^r_*frac1u^r d tilder_*\n\ncan be solved numerically from some initial value t(r_*^rm in)= - r_*^rm in outwards to make sure v(r_*^rm in)=t(r_*^rm in)+r_*^rm in=0.\n\nfunction t_of_rs(rs_out, a)\n    function f!(du, u, p, rs)\n        r = r_from_rstar(a, rs)\n        ur = -((sqrt(2) * r)/sqrt(r * (a^2 + r^2)))\n        du[1] = 1 / ur \n    end\n    rs_in = min(-100, 50*log10(1-a))\n    t0 = - rs_in\n    u0 = [t0]\n    prob = ODEProblem(f!, u0, (rs_in, rs_out))\n    sol = solve(prob, abstol=1e-8, reltol=1e-8)\n\n    return sol, rs_in, rs_out\nend\n\ntrs = t_of_rs(1000, 0.9)\nrs_values = range(-100, 100, 1000)\nv_values = [trs[1](rs)[1]+rs for rs in rs_values]\nplot(rs_values,\n    v_values,\n    xlabel = L\"r_*/M\",\n    ylabel = L\"v/M\",\n    label = L\"v(r_*)\",\n    legendfont = font(12,\"Computer Modern\"),\n    legendfontsize=14,\n    xguidefontsize=14,\n    yguidefontsize=14,\n    xtickfontsize=14,\n    ytickfontsize=14,\n    foreground_color_legend=nothing,\n    background_color_legend=nothing,\n    legend=:topright,\n    formatter=:latex,\n    linewidth=2.0,\n    left_margin = 2Plots.mm,\n    right_margin = 3Plots.mm)\n\n(Image: v_of_rs.png)\n\nWe precompue the integrals in mathcalW_nn as ODE solving problems. The truncation of the integral r_*^rm maxtoinfty can be set to some large numbers to make sure the convergence and precision.\n\nfunction precompute_W_integral(trs, f, a, omega)\n    trs_sol, rsmin, rsmax = trs\n    function f1!(du, u, p, rs)\n        r = r_from_rstar(a, rs)\n        du[1] = - f(r)[2] * exp(1im * omega * (trs_sol(rs)[1] + rs)) * (r^2 - 2*r + a^2)/(r^2 + a^2)\n    end\n    function f2!(du, u, p, rs)\n        r = r_from_rstar(a, rs)\n        du[1] = - f(r)[3] * exp(1im * omega * (trs_sol(rs)[1] + rs)) * (r^2 - 2*r + a^2)/(r^2 + a^2)\n    end\n    \n    u0 = ComplexF64[0.0]\n\n    prob1 = ODEProblem(f1!, u0, (rsmax, rsmin))\n    sol1 = solve(prob1, abstol=1e-8, reltol=1e-8)\n    \n\n    prob2 = ODEProblem(f2!, u0, (rsmax, rsmin))\n    sol2 = solve(prob2, abstol=1e-8, reltol=1e-8)\n\n    function f2r!(du, u, p, rs)\n        r = r_from_rstar(a, rs)\n        du[1] = - sol2(rs)[1] * (r^2 - 2*r + a^2)/(r^2 + a^2)\n    end\n\n    prob2r = ODEProblem(f2r!, u0, (rsmax, rsmin))\n    sol2r = solve(prob2r, abstol=1e-8, reltol=1e-8)\n\n    return sol1, sol2r\nend\n\nfunction Wnn_integrals(l, a, omega; rsout = 10000)\n    SH = spin_weighted_spheroidal_harmonic(-2, l, 0, a*omega)\n    S2 = SH(0, 0; theta_derivative=2)\n\n    f = f_terms(a, omega, S2)\n\n    rsout = max(rsout, 100pi*abs(omega)^(-1.0))\n    trs = t_of_rs(rsout * 3, a)\n\n    Wnn1, Wnn2 = precompute_W_integral(trs, f, a, omega)\n\n    function Wnn(rs)\n        r = r_from_rstar(a, rs)\n        χ =  omega * (trs[1](rs)[1] + rs)\n        phase = exp(1im * χ)\n        W = f(r)[1] * phase + Wnn1(rs)[1] + Wnn2(rs)[1]\n        return W\n    end\n    \n    return Wnn\nend\n\nOne can reproduce Figure 4(b) of our paper by\n\nrs_values = range(-50, 100, 1000)\nl = 2\na = 0.9\nω = 0.5\nW_1 = Wnn_integrals(l, a, ω)\nW_values = [W_1(rs)[1] for rs in rs_values]\nW1 = plot(rs_values,\n    real.(W_values),\n    xlabel = L\"r_{\\!\\!\\!\\! _*}/M\",\n    label = L\"\\mathrm{Re}\\ \\mathcal{W}\",\n    legendfont = font(12,\"Computer Modern\"),\n    legendfontsize=14,\n    xguidefontsize=14,\n    yguidefontsize=14,\n    xtickfontsize=14,\n    ytickfontsize=14,\n    foreground_color_legend=nothing,\n    background_color_legend=nothing,\n    legend=:topright,\n    formatter=:latex,\n    linewidth=2.0,\n    left_margin = 2Plots.mm,\n    right_margin = 3Plots.mm)\nplot!(rs_values,\n    imag.(W_values),\n    xlabel = L\"r_{\\!\\!\\!\\! _*}/M\",\n    label = L\"\\mathrm{Im}\\ \\mathcal{W}\",\n    legendfont = font(12,\"Computer Modern\"),\n    legendfontsize=14,\n    xguidefontsize=14,\n    yguidefontsize=14,\n    xtickfontsize=14,\n    ytickfontsize=14,\n    foreground_color_legend=nothing,\n    background_color_legend=nothing,\n    legend=:topright,\n    formatter=:latex,\n    linewidth=2.0,\n    left_margin = 2Plots.mm,\n    right_margin = 3Plots.mm)\n\n(Image: mathcalW.png)\n\nThen we do Green's function convolution integral defined by\n\nfracX_ell 0omega^inftyc_0=frac12iomega B_rm SN^rm incint_r_*^rm in^r_*^rm outfracDelta X_ell 0 omega^rm in(r_*)mathcalW_nn(r_*)r^2(r^2+a^2)^32e^-iomega r_*d r_*\n\n,\n\nwhere r_*^rm into -infty and r_*^rm outto +infty. According to our numerical experiment, r_*^rm in=rm minleft(-5050lg(1-a)right) and r_*^rm out=rm maxleft(5000 frac50piomegaright) are sufficient for us to achieve 10^-8 relative error.\n\nTo avoid integrating too far away, we define a new function \"baseline\" to find the baseline of the oscillatory integral and iterate the process by doubling the r_*^rm out until we find the baseline.\n\nfunction baseline(f, x0, x1; npoints=1000)\n\n    function compute_baseline(y::Vector{Float64})\n        raw_extrema = []\n        for i in 2:length(y)-1\n            if y[i] > y[i-1] && y[i] > y[i+1]\n                push!(raw_extrema, (i, y[i], :max))\n            elseif y[i] < y[i-1] && y[i] < y[i+1]\n                push!(raw_extrema, (i, y[i], :min))\n            end\n        end\n        if isempty(raw_extrema)\n            return NaN\n        end\n\n        cleaned = [raw_extrema[1]]\n        for i in 2:length(raw_extrema)\n            if raw_extrema[i][3] != cleaned[end][3]\n                push!(cleaned, raw_extrema[i])\n            end\n        end\n\n        types = [ext[3] for ext in cleaned]\n        nmax, nmin = count(==( :max), types), count(==( :min), types)\n        if nmax > nmin\n            cleaned = filter(e -> e[3] == :min || e !== last(cleaned), cleaned)\n        elseif nmin > nmax\n            cleaned = filter(e -> e[3] == :max || e !== last(cleaned), cleaned)\n        end\n\n        maxima = [y for (_, y, t) in cleaned if t == :max]\n        minima = [y for (_, y, t) in cleaned if t == :min]\n\n        if isempty(maxima) || isempty(minima)\n            return NaN\n        end\n\n        return (mean(maxima) + mean(minima)) / 2\n    end\n\n    xs = range(x0, x1; length=npoints)\n    ys = f.(xs)\n\n    baseline_real = compute_baseline(real.(ys))\n    baseline_imag = compute_baseline(imag.(ys))\n\n    return baseline_real + im * baseline_imag\nend\n\nfunction SN_convolution(l, omega, a; rsout = 5000, rsin = - 50)\n    s = -2\n    m = 0\n    rsin = min(rsin, 50*log10(1-a))\n    rsout = max(50pi*abs(omega)^(-1.0), rsout)\n    X = GSN_radial(s, l, m, a, omega, IN, rsin, rsout)\n    Binc = X.incidence_amplitude\n    W = Wnn_integrals(l, a, omega; rsout = rsout)\n    function integrand!(du, u, p, rs)\n        r = r_from_rstar(a, rs)\n        du[1] = W(rs)[1] * X(rs) * (r^2 - 2*r + a^2)/((r^2 + a^2)^(3/2)*r^2) * exp(-1im * omega * rs)\n    end\n    u0 = ComplexF64[0.0]\n    prob = ODEProblem(integrand!, u0, (rsin, rsout))\n    sol = solve(prob, abstol=1e-8, reltol=1e-8)\n    function soln(rs)\n        return sol(rs)[1] / (2im*omega*Binc)\n    end\n    Δr = 0.1*rsout\n    result = baseline(soln, rsout-Δr, rsout)\n\n    if abs(result) === NaN\n        return SN_convolution(l, omega, a; rsout = 2 * rsout, rsin = rsin)\n    else\n        return result\n    end\nend\n\n@time SN_convolution(2, 1e-3, 0.9)\n\n 11.004745 seconds (44.25 M allocations: 1.943 GiB, 9.33% gc time, 66.80% compilation time: <1% of which was recompilation)\n\n\n\n1.384211107451771 - 0.9020032118235283im\n\n@time SN_convolution(2, 0.5, 0.9)\n\n  0.745898 seconds (5.46 M allocations: 244.566 MiB, 1.75% compilation time)\n\n\n\n-0.011973774895345117 + 0.035421356682873745im\n\nWe compute the amplitude spectrum leftfracX_ell 0omega^inftyc_0right as a function of omega with ell=2 and a=09 as an example. The code will run for about 3 minutes on an Apple m2 air.\n\nomega_values_1 = range(-1.2, -0.01, 95)\nomega_values_2 = range(-0.01, -0.001, 6)\nomega_values_3 = range(0.001, 0.01, 6)\nomega_values_4 = range(0.01, 1.2, 95)\n# Alternative, nonuniform FFT can be used\nomega_values = union(omega_values_1, omega_values_2, omega_values_3, omega_values_4)\n@time AmpX_values_2_rest = [SN_convolution(2, omega, 0.9) for omega in omega_values]\nprintln()\n\n174.357890 seconds (1.21 G allocations: 53.720 GiB, 9.52% gc time, 0.01% compilation time)\n\nOne can reproduce the ell=2 curve in our Figure 6(a) by\n\nN = Int64(length(omega_values)/2)\nAmp_head_on_rest = plot(omega_values[N+1:2N],\n    abs.(AmpX_values_2_rest[N+1:2N]),\n    xlabel = L\"M\\omega\",\n    label = L\"\\ell=2\",\n    legendfont = font(12,\"Computer Modern\"),\n    yscale =:log10,\n    legendfontsize=14,\n    xguidefontsize=14,\n    yguidefontsize=14,\n    xtickfontsize=14,\n    ytickfontsize=14,\n    foreground_color_legend=nothing,\n    background_color_legend=nothing,\n    legend=:topright,\n    formatter=:latex,\n    linewidth=2.0,\n    left_margin = 2Plots.mm,\n    right_margin = 3Plots.mm,\n    ylim = (1e-6, 3))\n\n(Image: Xinf_omega_ell2.png)\n\nOne can also reproduce the ell=2 curve of the energy spectrum\n\nleft(fracd mathcalEdomegaright)_ell^infty=8omega^2mu^2left(leftfracX_ell 0omega^inftyc_0right^2+leftfracX_ell 0-omega^inftyc_0right^2right)\n\nin our Figure 6(b) by\n\nEomega_rest_2 = zeros(N)\nfor i in 1:N\n    Eomega_rest_2[i] = (abs2(AmpX_values_2_rest[N-i+1])+abs2(AmpX_values_2_rest[N+i]))*omega_values[N+i]^2*8\nend\nSpectrum_head_on_rest = plot(omega_values[N+1:2N],\n    Eomega_rest_2,\n    xlabel = L\"M\\omega\",\n    ylabel = L\"\\left.\\left\\langle d\\mathcal{E}/d\\omega\\right\\rangle^\\infty_\\ell\\right/(\\mathcal{E}^2\\mu^2)\",\n    label = L\"\\ell=2\",\n    legendfont = font(12,\"Computer Modern\"),\n    yscale =:log10,\n    legendfontsize=14,\n    xguidefontsize=14,\n    yguidefontsize=14,\n    xtickfontsize=14,\n    ytickfontsize=14,\n    foreground_color_legend=nothing,\n    background_color_legend=nothing,\n    legend=:topright,\n    formatter=:latex,\n    linewidth=2.0,\n    left_margin = 2Plots.mm,\n    right_margin = 3Plots.mm,\n    ylim = (1e-10, 1e-1))\n\n(Image: dEdomega_ell2.png)\n\nTo facilitate a smoother inverse Fourier transform, we use \"CubicSpline\" to interpolate the off-grid omega points to compute\n\nh_+-ih_times =sum_ell int_-infty^infty tildeh_ell(omega)e^-iomega u domega\n\n,\n\nwhere\n\ntildeh(omega)=frac8murfracX_ell 0omega^inftyc_0_-2S_ell 0^aomega(thetavarphi)\n\n.\n\nHere we still use ell=2 as an example.\n\nSince we have\n\nleftfracX_ell 0omegac_0rightsim omega^(ell -3)3\n\nwhich is divergent for ell=2 in the zero frequency limit. We can fix the error of ell=2 oriented from truncating omega_rm min=10^-3 analytically by\n\nint_0^omega_rm minomega^-13domega=frac32omega_rm min^23\n\n.\n\nOne can check this analytical fix by removing it from the following inverse FT function and plot the waveform. When it is removed, the waveform is not calibrated to zero (which could be misunderstood as memory effect) when u0.\n\nfunction hu(omega, amplitude, a, l, θ, ϕ)\n    N = Int64(length(omega))\n    amp_swsh = zeros(ComplexF64, N)\n    for i in 1:N\n        amp_swsh[i] = amplitude[i] * spin_weighted_spheroidal_harmonic(-2, l, 0, a*omega[i])(θ, ϕ)\n    end\n    spline_re = CubicSpline(omega, real.(amp_swsh))\n    spline_im = CubicSpline(omega, imag.(amp_swsh))\n    amp(ω) = spline_re(ω) + 1im * spline_im(ω)\n    function h_u(u)\n        h1 = quadgk(ω -> amp(ω) * exp(-1im * ω * u) * 8, 1e-3, omega[end])[1]\n        h2 = quadgk(ω -> amp(ω) * exp(-1im * ω * u) * 8, omega[1], -1e-3)[1]\n        h = h1 + h2\n        ### fix error\n        if l == 2\n            h += (amp(1e-3) + amp(-1e-3)) * (1e-3)^(2/3) * 3/2\n        end\n        ###\n        return h\n    end\n    return h_u\nend\n\nOne can reproduce the ell=2 waveform in our Figure 8 by\n\nu_values = range(-200, 200, 400)\nh2 = hu(omega_values, AmpX_values_2_rest, 0.9, 2, 0.5pi, 0.0)\nh2_values = [h2(u) for u in u_values]\nWaveform_head_on_rest_2 = plot(u_values,\n    real.(h2_values),\n    ylabel = L\"rh/\\mu\",\n    label = L\"\\ \\ h_{\\!\\!\\! +},\\ell=2\",\n    legendfontsize=14,\n    xguidefontsize=14,\n    yguidefontsize=14,\n    xtickfontsize=14,\n    ytickfontsize=14,\n    foreground_color_legend=nothing,\n    background_color_legend=nothing,\n    legend=:topright,\n    formatter=:latex,\n    linewidth= 2.0,\n    left_margin = 4Plots.mm,\n    right_margin = 2Plots.mm)\nplot!(u_values,\n    -imag.(h2_values),\n    ylabel = L\"rh/\\mu\",\n    label = L\"\\ \\ h_{\\!\\!\\! \\times},\\ell=2\",\n    legendfontsize=14,\n    xguidefontsize=14,\n    yguidefontsize=14,\n    xtickfontsize=14,\n    ytickfontsize=14,\n    foreground_color_legend=nothing,\n    background_color_legend=nothing,\n    legend=:topright,\n    formatter=:latex,\n    linestyle = :dot,\n    linewidth= 2.0,\n    left_margin = 4Plots.mm,\n    right_margin = 2Plots.mm)\n\n(Image: h_ell2.png)","category":"section"},{"location":"#Home","page":"Home","title":"Home","text":"GeneralizedSasakiNakamura.jl computes solutions to the frequency-domain radial Teukolsky equation with the Generalized Sasaki-Nakamura (GSN) formalism.\n\nThe code is capable of handling both ingoing and outgoing radiation of scalar, electromagnetic, and gravitational type (corresponding to spin weight of s = 0 pm 1 pm 2 respectively).\n\nThe angular Teukolsky equation is solved with an accompanying julia package SpinWeightedSpheroidalHarmonics.jl using a spectral decomposition method.\n\nBoth codes are capable of handling complex frequencies, and we use M = 1 convention throughout.\n\nThe paper describing both the GSN formalism and the implementation can be found in 2306.16469. A set of Mathematica notebooks deriving all the equations used in the code can be found in 10.5281/zenodo.8080241.\n\nStarting from v0.7.0, the code is also capable of computing the gravitational waveform and fluxes at infinity due a test particle orbiting around a Kerr black hole in a generic (eccentric, inclined) timelike bound orbit by solving the inhomogeneous SN equation using integration by parts.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"To install the package using the Julia package manager, simply type the following in the Julia REPL:\n\nusing Pkg\nPkg.add(\"GeneralizedSasakiNakamura\")\n\nNote: There is no need to install SpinWeightedSpheroidalHarmonics.jl separately as it should be automatically installed by the package manager.","category":"section"},{"location":"#Highlights","page":"Home","title":"Highlights","text":"","category":"section"},{"location":"#Performant-frequency-domain-Teukolsky-solver","page":"Home","title":"Performant frequency-domain Teukolsky solver","text":"Works well at both low and high frequencies, and takes only a few tens of milliseconds on average:\n\n<table>\n  <tr>\n    <th>GeneralizedSasakiNakamura.jl</th>\n    <th><a href=\"https://github.com/BlackHolePerturbationToolkit/Teukolsky\">Teukolsky</a> Mathematica package using the MST method </th>\n  </tr>\n  <tr>\n    <td><p align=\"center\"><img width=\"100%\" src=\"https://github-production-user-asset-6210df.s3.amazonaws.com/55488840/248965077-7d216deb-5bae-433f-a699-d40a35f0e35d.gif\"></p></td>\n    <td><p align=\"center\"><img width=\"100%\" src=\"https://github-production-user-asset-6210df.s3.amazonaws.com/55488840/248966033-9e7d8027-81ee-4762-98d9-0ad0a1c030ad.gif\"></p></td>\n  </tr>\n</table>\n\n(There was no caching! We solved the equation on-the-fly! The notebook generating this animation can be found here)\n\nStatic/zero-frequency solutions are solved analytically with Gauss hypergeometric functions.","category":"section"},{"location":"#Solutions-that-are-accurate-everywhere","page":"Home","title":"Solutions that are accurate everywhere","text":"Numerical solutions are smoothly stitched to analytical ansatzes near the horizon and infinity at user-specified locations rsin and rsout respectively:\n\n<p align=\"center\">\n  <img width=\"50%\" src=\"https://github-production-user-asset-6210df.s3.amazonaws.com/55488840/248724944-9707332b-1238-4b3b-b1c0-ac426a1b3dc6.gif\">\n</p>","category":"section"},{"location":"#Easy-to-use","page":"Home","title":"Easy to use","text":"The following code snippet lets you solve the (source-free) Teukolsky function (in frequency domain) for the mode s=-2 ell=2 m=2 aM=07 Momega=05 that satisfies the purely-ingoing boundary condition at the horizon, R^textrmin, and the purely-outgoing boundary condition at spatial infinity, R^textrmup, respectively:\n\nusing GeneralizedSasakiNakamura # This is going to take some time to pre-compile, mostly due to DifferentialEquations.jl\n\n# Specify which mode to solve\ns=-2; l=2; m=2; a=0.7; omega=0.5;\n\n# NOTE: julia uses 'just-ahead-of-time' compilation. Calling this the first time in each session will take some time\nRin, Rup = Teukolsky_radial(s, l, m, a, omega)\n\nThat's it! If you run this on Julia REPL, it should give you something like this\n\n(TeukolskyRadialFunction(mode=Mode(s=-2, l=2, m=2, a=0.7, omega=0.5, lambda=1.696609401635342), boundary_condition=IN), TeukolskyRadialFunction(mode=Mode(s=-2, l=2, m=2, a=0.7, omega=0.5, lambda=1.696609401635342), boundary_condition=UP))\n\nIn Julia REPL, you can check out all the asymptotic amplitudes at a glimpse using something like\n\njulia> Rin\nTeukolskyRadialFunction(\n    mode=Mode(s=-2, l=2, m=2, a=0.7, omega=0.5, lambda=1.696609401635342),\n    boundary_condition=IN,\n    transmission_amplitude=1.0 + 0.0im,\n    incidence_amplitude=6.5365876612287765 - 4.9412038970871555im,\n    reflection_amplitude=-0.1282466191307726 - 0.440481334972911im,\n    normalization_convention=UNIT_TEUKOLSKY_TRANS\n)\n\nFor example, if we want to evaluate the Teukolsky function R^textrmin at the location r = 10M, simply do\n\nRin(10)\n\nThis should give\n\n77.57508416835319 - 429.40290952262677im","category":"section"},{"location":"#Solving-for-complex-frequencies","page":"Home","title":"Solving for complex frequencies","text":"One can use the same interface to compute solutions with complex frequencies. For example, the QNM solution of the s=-2 ell=2 m=2 aM=068 fundamental tone can be obtained using\n\nRin, Rup = Teukolsky_radial(-2, 2, 2, 0.68, 0.5239751-0.0815126im)\n\nWe can check out the R^textrmup solution using\n\njulia> Rup\nTeukolskyRadialFunction(\n    mode=Mode(s=-2, l=2, m=2, a=0.68, omega=0.5239751 - 0.0815126im, lambda=1.655003080578682 + 0.3602676563885877im),\n    boundary_condition=UP,\n    transmission_amplitude=1.0 + 0.0im,\n    incidence_amplitude=-5.850900444651249e-8 - 3.80716581300155e-7im,\n    reflection_amplitude=1.1011632133920028 + 2.1300597377432497im,\n    normalization_convention=UNIT_TEUKOLSKY_TRANS\n)\n\nWe see that the incidence amplitude is indeed very small numerically as a QNM solution should. This can be accessed using\n\nRup.incidence_amplitude\n\nThis should give\n\n-5.850900444651249e-8 - 3.80716581300155e-7im","category":"section"},{"location":"#Solving-the-inhomogeneous-radial-Teukolsky/SN-equation-with-a-point-particle-source-on-a-generic-timelike-bound-orbit","page":"Home","title":"Solving the inhomogeneous radial Teukolsky/SN equation with a point-particle source on a generic timelike bound orbit","text":"This can now be done easily with this code. Suppose we want to compute the inhomogeneous solution to the radial Teukolsky equation at infinity for the s = -2, ell = m = 2 mode driven by a test particle on a bound geodesic with aM = 09 p = 6M e = 07 x = cos(pi4), one can simply do\n\nmode_info = Teukolsky_pointparticle_mode(-2, 2, 2, 0, 0, 0.9, 6, 0.7, cos(π/4))\n\nwhere n = 0 and k = 0 label the radial and polar modes, respectively. To have a glimpse of the output, one can do so with\n\njulia> mode_info\nTeukolskyPointParticleMode(\n    mode=Mode(s=-2, l=2, m=2, a=0.9, omega=0.06568724726732737, lambda=3.6067890121199833),\n    amplitude_inf=0.00023429507957491088 - 6.558414418883069e-5im,\n    energy_flux_inf=1.091733010828344e-6,\n    angular_momentum_flux_inf=3.3240333740438795e-5,\n    Carter_const_flux_inf=5.890504440487091e-5,\n    method=(method = \"trapezoidal\", N = 256, K = 64),\n)\n\nTo access for example the amplitude at infinity\n\njulia> mode_info.amplitude\n0.00023429507957491088 - 6.558414418883069e-5im\n\nwhich is the value for Z^infty_ell m n k, the amplitude of the inhomogeneous radial Teukolsky solution near infinity for that particular frequency.\n\nIf we want to compute the inhomogeneous solution to the radial Teukolsky equation at the event horizon for the  same set of parameters, we can simply change the sign of to s = 2\n\nmode_info = Teukolsky_pointparticle_mode(2, 2, 2, 0, 0, 0.9, 6, 0.7, cos(π/4))\n\nThe output should be\n\njulia> mode_info\nTeukolskyPointParticleMode(\n    mode=Mode(s=2, l=2, m=2, a=0.9, omega=0.06568724726732737, lambda=-0.3932109878800167),\n    amplitude_hor=0.006089946888787634 - 0.0014130019665122818im,\n    energy_flux_hor=-2.843814878427963e-9,\n    angular_momentum_flux_hor=-8.658651402621547e-8,\n    Carter_const_flux_hor=-1.5343956812841173e-7,\n    method=(method = \"trapezoidal\", N = 256, K = 64),\n)\n\nTo access for example the amplitude at the horizon\n\njulia> mode_info.amplitude\n0.006089946888787634 - 0.0014130019665122818im\n\nwhich is the value for Z^mathrmH_ell m n k, the amplitude of the inhomogeneous radial Teukolsky solution near the horizon for that particular frequency.","category":"section"},{"location":"#How-to-cite","page":"Home","title":"How to cite","text":"If you have used this code in your research that leads to a publication, please cite the following article:\n\n@article{Lo:2023fvv,\n    author = \"Lo, Rico K. L.\",\n    title = \"{Recipes for computing radiation from a Kerr black hole using a generalized Sasaki-Nakamura formalism: Homogeneous solutions}\",\n    eprint = \"2306.16469\",\n    archivePrefix = \"arXiv\",\n    primaryClass = \"gr-qc\",\n    doi = \"10.1103/PhysRevD.110.124070\",\n    journal = \"Phys. Rev. D\",\n    volume = \"110\",\n    number = \"12\",\n    pages = \"124070\",\n    year = \"2024\"\n}\n\nAdditionally, if you have used this code's capability to solve for solutions with complex frequencies, please also cite the following article:\n\n@article{Lo:2025njp,\n    author = \"Lo, Rico K. L. and Sabani, Leart and Cardoso, Vitor\",\n    title = \"{Quasinormal modes and excitation factors of Kerr black holes}\",\n    eprint = \"2504.00084\",\n    archivePrefix = \"arXiv\",\n    primaryClass = \"gr-qc\",\n    doi = \"10.1103/PhysRevD.111.124002\",\n    journal = \"Phys. Rev. D\",\n    volume = \"111\",\n    number = \"12\",\n    pages = \"124002\",\n    year = \"2025\"\n}\n\nIf you have used this code's capability to solve for the gravitational waveform amplitude and fluxes at infinity with a test particle orbiting a Kerr black hole in a generic timelike bound and stable orbit (e.g., for extreme mass ratio inspiral waveforms), please cite the following article:\n\n@article{Yin:2025kls,\n    author = \"Yin, Yucheng and Lo, Rico K. L. and Chen, Xian\",\n    title = \"{Gravitational radiation from Kerr black holes using the Sasaki-Nakamura formalism: waveforms and fluxes at infinity}\",\n    eprint = \"2511.08673\",\n    archivePrefix = \"arXiv\",\n    primaryClass = \"gr-qc\",\n    month = \"11\",\n    year = \"2025\"\n}","category":"section"},{"location":"#License","page":"Home","title":"License","text":"The package is licensed under the MIT License.","category":"section"}]
}
